import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import { fileURLToPath } from 'node:url'

import { apiCategories } from '@saltify/milky-types/api'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const pkgRoot = path.resolve(__dirname, '..')

const openapiPath = path.join(pkgRoot, 'src', 'api', 'openapi.json')
const outPath = path.join(pkgRoot, 'src', 'api', 'definitions.generated.ts')

const quote = (value) => JSON.stringify(value)

function getEndpointSummaries(openapi) {
	const paths = openapi?.paths ?? {}
	const summaries = new Map()

	for (const [p, item] of Object.entries(paths)) {
		if (!p.startsWith('/api/')) continue
		const endpoint = p.slice('/api/'.length)
		const method = item?.post ?? item?.get ?? item?.put ?? item?.patch ?? item?.delete ?? null
		const summary = typeof method?.summary === 'string' ? method.summary : ''
		summaries.set(endpoint, summary)
	}

	return summaries
}

function getMilkyTypeDefinitions() {
	const defs = new Map()
	for (const cat of Object.values(apiCategories)) {
		for (const api of cat.apis) {
			defs.set(api.endpoint, {
				description: api.description,
				inputStruct: api.inputStruct ?? null,
				outputStruct: api.outputStruct ?? null,
			})
		}
	}
	return defs
}

function buildDefinitions({ endpoints, openapiSummaries, milkyTypes }) {
	const out = []
	for (const endpoint of endpoints) {
		const typeDef = milkyTypes.get(endpoint)
		out.push({
			endpoint,
			description: typeDef?.description ?? openapiSummaries.get(endpoint) ?? '',
			inputStruct: typeDef?.inputStruct ?? null,
			outputStruct: typeDef?.outputStruct ?? null,
		})
	}
	return out
}

async function readOptionalOpenapi() {
	try {
		const raw = await fs.readFile(openapiPath, 'utf8')
		return JSON.parse(raw)
	} catch {
		return null
	}
}

async function main() {
	const openapi = await readOptionalOpenapi()
	const openapiSummaries = getEndpointSummaries(openapi)
	const milkyTypes = getMilkyTypeDefinitions()

	const endpoints = (openapi
		? Object.keys(openapi?.paths ?? {})
				.filter((p) => p.startsWith('/api/'))
				.map((p) => p.slice('/api/'.length))
		: [...milkyTypes.keys()]
	).sort((a, b) => a.localeCompare(b))

	if (openapi) {
		const missingInTypes = endpoints.filter((e) => !milkyTypes.has(e))
		const extraInTypes = [...milkyTypes.keys()].filter((e) => !openapiSummaries.has(e))

		if (missingInTypes.length) {
			console.warn('[milky] endpoints missing in @saltify/milky-types/api:', missingInTypes)
		}
		if (extraInTypes.length) {
			console.warn('[milky] endpoints missing in openapi.json:', extraInTypes)
		}
	}

	const defs = buildDefinitions({ endpoints, openapiSummaries, milkyTypes })

	const lines = []
	lines.push('/* eslint-disable */')
	lines.push('// This file is generated by `scripts/generate-api-definitions.mjs`.')
	lines.push('// Source: `@saltify/milky-types/api` (+ optional `src/api/openapi.json`).')
	lines.push('')
	lines.push('export const MILKY_API_DEFINITIONS = [')
	for (const d of defs) {
		lines.push(
			`\t{ endpoint: ${quote(d.endpoint)}, description: ${quote(d.description)}, inputStruct: ${
				d.inputStruct ? quote(d.inputStruct) : 'null'
			}, outputStruct: ${d.outputStruct ? quote(d.outputStruct) : 'null'} },`,
		)
	}
	lines.push('] as const')
	lines.push('')
	lines.push('export type MilkyApiDefinition = (typeof MILKY_API_DEFINITIONS)[number]')
	lines.push('export type MilkyApiEndpoint = MilkyApiDefinition[\'endpoint\']')
	lines.push(
		'export type MilkyApiDefinitionByEndpoint<E extends MilkyApiEndpoint> = Extract<MilkyApiDefinition, { endpoint: E }>',
	)
	lines.push('')

	await fs.writeFile(outPath, `${lines.join('\n')}\n`, 'utf8')
	console.log(`[milky] wrote ${path.relative(process.cwd(), outPath)} (${defs.length} endpoints)`)
}

main().catch((e) => {
	console.error(e)
	process.exitCode = 1
})
